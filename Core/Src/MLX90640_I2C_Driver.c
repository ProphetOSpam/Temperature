#include "MLX90640_I2C_Driver.h"

#include <stdio.h>
#include "stm32f4xx_hal.h"
#include "endian.h"
#include "print.h"

#define min(a, b) ((a < b) ? a : b)

#define MLX90640_I2C_TIMEOUT_MS 1000
#define MLX90640_I2C_AMOUNT_PER_READ (1 << 0)

extern I2C_HandleTypeDef hi2c3;


// Copied from autogenerated config, not really needed
/**
  * @brief I2C3 Initialization Function
  * @param None
  * @retval None
  */
//void MLX90640_I2CInit(void) {
//  hi2c3.Instance = I2C3;
//  hi2c3.Init.ClockSpeed = 100000;
//  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
//  hi2c3.Init.OwnAddress1 = 0;
//  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
//  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
//  hi2c3.Init.OwnAddress2 = 0;
//  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
//  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
//  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
//  {
//    Error_Handler();
//  }
//
//  /** Configure Analogue filter
//  */
//  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
//  {
//    Error_Handler();
//  }
//
//  /** Configure Digital filter
//  */
//  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
//  {
//    Error_Handler();
//  }
//}

int MLX90640_I2CGeneralReset(void) {
	HAL_I2C_DeInit(&hi2c3);
	HAL_I2C_Init(&hi2c3);
//	__HAL_I2C_DISABLE(&hi2c3);
//
//	// Flash the software reset bit
//	SET_BIT(hi2c3.Instance->CR1, I2C_CR1_SWRST);
//	CLEAR_BIT(hi2c3.Instance->CR1, I2C_CR1_SWRST);
//
//	__HAL_I2C_ENABLE(&hi2c3);

	// Maybe necessary?
//	hi2c3.ErrorCode = HAL_I2C_ERROR_NONE;
//	hi2c3.State = HAL_I2C_STATE_READY;
//	hi2c3.PreviousState = HAL_I2C_MODE_NONE;
//	hi2c3.Mode = HAL_I2C_MODE_NONE;

	return 0;
}

int MLX90640_I2CRead(uint8_t slaveAddr, uint16_t startAddress, uint16_t nMemAddressRead, uint16_t *data) {
	// Even though data is uint16_t[] and HAL_I2C_Mem_Read expects uint8_t[], I think its fine because the old driver also operated similar to this
	// https://github.com/melexis/mlx90640-library/blob/7d50aaced1cc8de68a2351629848d803128758ea/functions/functions/MLX90640_SWI2C_Driver.cpp#L102
	// 																																   Nice align ^
	// Fun fact it was not fine, gotta swap the endianness
	unsigned amount_per_read = min(nMemAddressRead, MLX90640_I2C_AMOUNT_PER_READ);

	uint16_t i;
	for (i = 0; i < nMemAddressRead; i += amount_per_read) {
		HAL_StatusTypeDef result = HAL_I2C_Mem_Read(
				&hi2c3,
				slaveAddr << 1,
				startAddress + i,
				I2C_MEMADD_SIZE_16BIT,
				(uint8_t *) (data + i),
				amount_per_read * sizeof(uint16_t),
				MLX90640_I2C_TIMEOUT_MS);
//		print_binary(data + i);

		if (result != HAL_OK) {
			println("I2C error code: %lu", hi2c3.ErrorCode);
			return -1;
		}

		// MLX driver manual, section 2 sayeth: reverse that endianness
		swpend(data + i, amount_per_read);
//		for (uint16_t j = i; j < i + amount_per_read; j++) {
//			swpend(data + j, sizeof(uint16_t));
//		}
	}

	uint16_t final_read_amount = nMemAddressRead - i;

	if (final_read_amount > 0) {
		HAL_StatusTypeDef result = HAL_I2C_Mem_Read(
						&hi2c3,
						slaveAddr << 1,
						startAddress + i,
						I2C_MEMADD_SIZE_16BIT,
						(uint8_t *) (data + i),
						final_read_amount * sizeof(uint16_t),
						MLX90640_I2C_TIMEOUT_MS);

		if (result != HAL_OK) {
			println("I2C error code: %lu", hi2c3.ErrorCode);
			return -1;
		}

		// MLX driver manual, section 2 sayeth: reverse that endianness
		swpend(data + i, amount_per_read);
//		for (uint16_t j = i; j < i + final_read_amount; j++) {
//			swpend(data + j, sizeof(uint16_t));
//		}
	}

	return 0;
}

int MLX90640_I2CWrite(uint8_t slaveAddr, uint16_t writeAddress, uint16_t data) {
	uint8_t dataSize = sizeof(uint16_t);

	// MLX driver manual, section 2 sayeth: reverse that endianness
	swpend(&data, sizeof(uint16_t));

	HAL_StatusTypeDef result = HAL_I2C_Mem_Write(&hi2c3, slaveAddr << 1, writeAddress, I2C_MEMADD_SIZE_16BIT, (uint8_t *) &data, dataSize, MLX90640_I2C_TIMEOUT_MS);
	if (result != HAL_OK) {
		println("I2C error code: %lu", hi2c3.ErrorCode);
		return -1;
	}

	return 0;
}

void MLX90640_I2CFreqSet(int freq) {
	// Disable the peripheral while changing registers
	// I dunno if this actually does anything, but the stuff in hal_i2c.c did it so I'll do it too.
	__HAL_I2C_DISABLE(&hi2c3);

	// Flash the software reset bit
	SET_BIT(hi2c3.Instance->CR1, I2C_CR1_SWRST);
	CLEAR_BIT(hi2c3.Instance->CR1, I2C_CR1_SWRST);

	/* Get PCLK1 frequency */
	uint32_t pclk1 = HAL_RCC_GetPCLK1Freq();

	/* Calculate frequency range */
	uint32_t freqrange = I2C_FREQRANGE(pclk1);

	/*---------------------------- I2Cx CR2 Configuration ----------------------*/
	/* Configure I2Cx: Frequency range */
	MODIFY_REG(hi2c3.Instance->CR2, I2C_CR2_FREQ, freqrange);

	/*---------------------------- I2Cx TRISE Configuration --------------------*/
	/* Configure I2Cx: Rise Time */
	MODIFY_REG(hi2c3.Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c3.Init.ClockSpeed));

	/*---------------------------- I2Cx CCR Configuration ----------------------*/
	/* Configure I2Cx: Speed */
	MODIFY_REG(hi2c3.Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c3.Init.ClockSpeed, hi2c3.Init.DutyCycle));

	__HAL_I2C_ENABLE(&hi2c3);
}
